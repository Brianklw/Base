# Create a PC + Mobile friendly single-file HTML game base
html = r"""<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="theme-color" content="#0b0b0b" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>One-File Game Base — PC + Mobile</title>
  <style>
    :root {
      --bg:#0b0b0b; --fg:#e8e8e8; --muted:#9aa3ad;
      --panel:#101010; --border:#1e1e1e; --accent:#9bdcff;
      --pad-top: env(safe-area-inset-top, 0px);
      --pad-right: env(safe-area-inset-right, 0px);
      --pad-bottom: env(safe-area-inset-bottom, 0px);
      --pad-left: env(safe-area-inset-left, 0px);
    }
    * { box-sizing:border-box; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; 
           -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; overscroll-behavior:none; }
    #wrap { display:grid; grid-template-rows:auto 1fr auto; height:100%; padding:var(--pad-top) var(--pad-right) var(--pad-bottom) var(--pad-left); gap:0; }
    header, footer { padding:8px 12px; }
    header { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .pill { background:var(--panel); border:1px solid var(--border); padding:4px 10px; border-radius:999px; font-weight:600; }
    .tip { color:var(--muted); font-size:.92rem; }
    #hud { margin-left:auto; display:flex; gap:10px; align-items:center; }
    button { background:#1a1a1a; color:#fff; border:1px solid #333; border-radius:10px; padding:10px 14px; font:inherit; cursor:pointer; touch-action:manipulation; min-width:46px; min-height:40px; }
    button:active { transform:translateY(1px); }
    canvas { display:block; width:100%; height:100%; touch-action:none; }
    #controls { position:fixed; inset:auto 0 var(--pad-bottom) 0; pointer-events:none; display:none; }
    .zone { position:absolute; bottom:12px; width:45vw; height:28vh; max-height:38vh; pointer-events:auto; }
    #zoneL { left:12px; }
    #zoneR { right:12px; }
    .zone .hint { position:absolute; bottom:10px; left:10px; right:10px; height:70px; border:1px dashed #333; border-radius:14px; opacity:.3; }
    /* Show on touchscreen devices */
    @media (hover:none) and (pointer:coarse) { #controls { display:block; } }
    /* Readme panel */
    details { background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:10px 12px; margin:8px 12px; }
    code, pre { background:#0e0e0e; border:1px solid #222; border-radius:6px; padding:2px 6px; }
    pre { overflow:auto; padding:10px; }
    a { color:var(--accent); }
    /* Orientation tip */
    #orientationTip { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.5); z-index:9; text-align:center; padding:24px; }
    #orientationTip .box { background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; max-width:520px; }
    @media (max-height:420px) and (orientation:portrait) { #orientationTip { display:flex; } }
  </style>
</head>
<body>
  <div id="wrap">
    <header>
      <span class="pill">One-File Game Base</span>
      <span class="tip">PC: WASD/Arrows • Mobile: use left/right zones • Press ? for README</span>
      <div id="hud">
        <div>FPS: <b id="fps">0</b></div>
        <div>Score: <b id="score">0</b></div>
        <div>Best: <b id="best">0</b></div>
        <button id="fsBtn" title="Fullscreen">⛶</button>
        <button id="pauseBtn" aria-pressed="false">Pause</button>
        <button id="resetBtn">Reset</button>
      </div>
    </header>

    <canvas id="view" aria-label="Game canvas" role="img"></canvas>

    <footer class="tip">Single-file • Canvas + Web Audio • WASM-ready • Gamepad/Touch supported</footer>
  </div>

  <!-- Touch controls overlay -->
  <div id="controls" aria-hidden="true">
    <div id="zoneL" class="zone"><div class="hint"></div></div>
    <div id="zoneR" class="zone"><div class="hint"></div></div>
  </div>

  <!-- Orientation tip for short portrait -->
  <div id="orientationTip">
    <div class="box">
      <b>Pro tip:</b> Rotate your device for more screen space. You can play in portrait too. Tap to dismiss.
    </div>
  </div>

  <!-- README / vibe coding guide -->
  <details id="readme"><summary><b>README (click to expand)</b></summary>
    <p><b>PC + Mobile Game Base:</b> single-file with fixed timestep, input (keyboard/touch/gamepad), audio, saves, and WASM hooks.</p>
    <ul>
      <li>Keep JS↔WASM calls chunky (few calls, typed arrays).</li>
      <li>Use seeded RNG for determinism & replays.</li>
      <li>Prefer procedural assets; inline data: URIs for any art.</li>
      <li>Pause on <code>visibilitychange</code> is enabled; resume with input.</li>
    </ul>
    <pre>// Suggested WASM surface
// (memory exported), init(seed), step(ptrIn, ptrOut)
</pre>
  </details>

  <script type="module">
    // =========================
    // Utils
    // =========================
    const DPR = Math.max(1, Math.min(3, devicePixelRatio || 1));
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand=(a=0,b=1)=>a+Math.random()*(b-a);
    const isTouch = matchMedia('(hover:none) and (pointer:coarse)').matches;

    // =========================
    // Canvas
    // =========================
    const canvas = document.getElementById('view');
    const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
    function resize(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      canvas.width = Math.max(1, Math.floor(w*DPR));
      canvas.height= Math.max(1, Math.floor(h*DPR));
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    new ResizeObserver(resize).observe(canvas);

    // =========================
    // Audio (unlock on user gesture)
    // =========================
    let audioCtx;
    function ensureAudio(){
      audioCtx ||= new (window.AudioContext||window.webkitAudioContext)();
      return audioCtx;
    }
    function beep(freq=700, dur=0.06, type='square', vol=0.05){
      try{
        ensureAudio();
        const o=audioCtx.createOscillator(), g=audioCtx.createGain();
        o.type=type; o.frequency.value=freq; g.gain.value=vol;
        o.connect(g).connect(audioCtx.destination);
        const t=audioCtx.currentTime; o.start(t);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        o.stop(t+dur+0.01);
      }catch{}
    }

    // =========================
    // Input: keyboard, touch zones, gamepad
    // =========================
    const keys=new Set();
    addEventListener('keydown',e=>{
      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','a','d','w','s',' '].includes(e.key)) e.preventDefault();
      if(e.key==='?') document.getElementById('readme').open = !document.getElementById('readme').open;
      if(e.key===' ') togglePause();
      keys.add(e.key);
      if(!audioCtx) { try{ensureAudio();}catch{} }
    });
    addEventListener('keyup',e=>keys.delete(e.key));

    // Touch zones
    const zoneL = document.getElementById('zoneL');
    const zoneR = document.getElementById('zoneR');
    const pointer = { left:false, right:false, lx:0, ly:0, rx:0, ry:0 };
    function bindZone(zone, side){
      zone.addEventListener('pointerdown', e=>{
        zone.setPointerCapture(e.pointerId);
        if(side==='L'){ pointer.left=true; pointer.lx=e.clientX; pointer.ly=e.clientY; }
        else { pointer.right=true; pointer.rx=e.clientX; pointer.ry=e.clientY; }
        if(!audioCtx){ try{ensureAudio();}catch{} }
      });
      zone.addEventListener('pointermove', e=>{
        if(side==='L'){ pointer.lx=e.clientX; pointer.ly=e.clientY; }
        else { pointer.rx=e.clientX; pointer.ry=e.clientY; }
      });
      zone.addEventListener('pointerup', e=>{
        try{ zone.releasePointerCapture(e.pointerId); }catch{}
        if(side==='L') pointer.left=false; else pointer.right=false;
      });
      zone.addEventListener('pointercancel', ()=>{ if(side==='L') pointer.left=false; else pointer.right=false; });
    }
    bindZone(zoneL,'L'); bindZone(zoneR,'R');

    // Gamepad
    let gpIndex=null;
    window.addEventListener('gamepadconnected', e=>{ gpIndex=e.gamepad.index; });
    window.addEventListener('gamepaddisconnected', e=>{ if(gpIndex===e.gamepad.index) gpIndex=null; });
    function pollGamepad(){
      if(gpIndex==null) return { x:0, y:0, a:false };
      const gp = navigator.getGamepads()[gpIndex];
      if(!gp) return { x:0, y:0, a:false };
      const x = (gp.axes[0]||0), y=(gp.axes[1]||0), a=gp.buttons[0]?.pressed||false;
      return { x, y, a };
    }

    // Pause on tab hidden
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden){ state.running=false; updatePauseBtn(); }
    });

    // Fullscreen
    document.getElementById('fsBtn').onclick = () => {
      if(document.fullscreenElement) document.exitFullscreen();
      else document.documentElement.requestFullscreen().catch(()=>{});
    };

    // Orientation tip dismiss
    document.getElementById('orientationTip').addEventListener('click', e=> e.currentTarget.style.display='none');

    // =========================
    // Save
    // =========================
    const SAVE_KEY='onefile-base-best';
    const save = {
      best: Number(localStorage.getItem(SAVE_KEY)||0),
      write(v){ try{
        localStorage.setItem(SAVE_KEY+'.tmp', String(v));
        localStorage.setItem(SAVE_KEY, String(v));
        localStorage.removeItem(SAVE_KEY+'.tmp');
      }catch{} }
    };

    // =========================
    // State
    // =========================
    const hud = {
      fps: document.getElementById('fps'),
      score: document.getElementById('score'),
      best: document.getElementById('best'),
      pauseBtn: document.getElementById('pauseBtn'),
    };
    const state = {
      running:true,
      score:0,
      best: save.best,
      player:{ x:160, y:160, vx:0, vy:0, r:16 },
      hazards:[], lastSpawn:0, speed:1
    };
    hud.best.textContent=state.best;
    document.getElementById('resetBtn').onclick = ()=> resetGame();
    hud.pauseBtn.onclick = ()=> togglePause();
    function updatePauseBtn(){
      hud.pauseBtn.textContent = state.running ? 'Pause' : 'Resume';
      hud.pauseBtn.setAttribute('aria-pressed', String(!state.running));
    }
    function togglePause(){ state.running=!state.running; updatePauseBtn(); if(state.running) lastT=performance.now(); }
    function resetGame(){
      state.score=0; state.speed=1; state.hazards.length=0;
      state.player.x = canvas.clientWidth/2; state.player.y = canvas.clientHeight/2;
      state.player.vx=state.player.vy=0; state.running=true; updatePauseBtn(); lastT=performance.now();
    }

    // =========================
    // WASM (optional) — paste Base64 on one line
    // =========================
    const WASM_BASE64 = ""; // put your Base64 here to enable WASM
    let wasm=null;
    function b64ToBytes(b64){ const bin=atob(b64); const out=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i); return out; }
    (async ()=>{
      if(!WASM_BASE64) return;
      try {
        const { instance } = await WebAssembly.instantiate(b64ToBytes(WASM_BASE64), {});
        wasm = instance;
        if(wasm.exports?.init) wasm.exports.init((Math.random()*0xffffffff)>>>0);
        console.log('WASM exports:', Object.keys(wasm.exports));
      } catch (e) { console.warn('WASM init failed', e); }
    })();

    // =========================
    // Game loop
    // =========================
    const FIXED_DT=1/60; let acc=0, lastT=performance.now(), frames=0, fpsTimer=0;
    function loop(tNow){
      requestAnimationFrame(loop);
      const dt = Math.min(0.25, (tNow-lastT)/1000); lastT=tNow;
      fpsTimer+=dt; frames++; if (fpsTimer>=0.5){ hud.fps.textContent = Math.round(frames/fpsTimer); fpsTimer=0; frames=0; }
      if(!state.running) return;
      acc+=dt; while(acc>=FIXED_DT){ update(FIXED_DT); acc-=FIXED_DT; }
      render();
    }
    requestAnimationFrame(loop);

    function spawnHazard(){
      const w=canvas.clientWidth, h=canvas.clientHeight;
      state.hazards.push({ x:rand(20,w-20), y:-30, r:rand(10,22), vy:rand(120,200)*state.speed, rot:rand(0,Math.PI), vr:rand(-2,2) });
    }

    function update(dt){
      // Inputs: keyboard
      const accel = 900, friction=0.86;
      let ax=0, ay=0;
      if(keys.has('ArrowLeft') || keys.has('a')) ax -= 1;
      if(keys.has('ArrowRight')|| keys.has('d')) ax += 1;
      if(keys.has('ArrowUp')   || keys.has('w')) ay -= 1;
      if(keys.has('ArrowDown') || keys.has('s')) ay += 1;

      // Touch zones: move horizontally on left, action on right
      if(isTouch && pointer.left){
        // map left zone X relative movement to horizontal accel
        // normalize around zone center
        const rect = zoneL.getBoundingClientRect();
        const nx = ((pointer.lx - rect.left) / Math.max(1, rect.width)) * 2 - 1; // -1..1
        ax += clamp(nx, -1, 1);
      }
      // Right zone "action" (speed boost)
      let boosting = false;
      if(isTouch && pointer.right){ boosting = true; }

      // Gamepad
      const gp = pollGamepad();
      ax += clamp(gp.x, -1, 1);
      ay += clamp(gp.y, -1, 1);
      boosting = boosting || gp.a;

      // Apply accel
      state.player.vx += ax * accel * dt * (boosting?1.4:1);
      state.player.vy += ay * accel * dt;
      state.player.vx *= friction; state.player.vy *= friction;
      state.player.x = clamp(state.player.x + state.player.vx*dt, 16, canvas.clientWidth-16);
      state.player.y = clamp(state.player.y + state.player.vy*dt, 16, canvas.clientHeight-16);

      // Hazards
      state.lastSpawn += dt;
      if(state.lastSpawn > Math.max(0.18, 0.9 - 0.015*state.score)){ state.lastSpawn=0; spawnHazard(); }
      for(let i=state.hazards.length-1;i>=0;i--){
        const hz=state.hazards[i]; hz.y += hz.vy*dt; hz.rot += hz.vr*dt;
        if(hz.y - hz.r > canvas.clientHeight + 40) state.hazards.splice(i,1);
      }

      // Collisions
      for(const hz of state.hazards){
        const dx=hz.x-state.player.x, dy=hz.y-state.player.y, rr=(hz.r+state.player.r)**2;
        if(dx*dx+dy*dy < rr){
          try{ navigator.vibrate?.(60); }catch{}
          beep(180, 0.08, 'sawtooth', 0.1);
          state.best = Math.max(state.best, state.score); save.write(state.best);
          state.score = 0; state.hazards.length=0; state.speed=1;
          break;
        }
      }

      // Score & difficulty
      state.score += dt*2; state.speed = 1 + state.score*0.02;
      hud.score.textContent = Math.floor(state.score);
      hud.best.textContent = Math.floor(state.best);

      // Optional WASM step
      if(wasm && wasm.exports?.step && wasm.exports?.memory){
        // Example pattern:
        // const mem = new DataView(wasm.exports.memory.buffer);
        // mem.setFloat32(0, dt, true);
        // wasm.exports.step(0, 0);
      }
    }

    function render(){
      const w=canvas.width/DPR, h=canvas.height/DPR;
      ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0,0,w,h);

      // Player
      ctx.save();
      ctx.translate(state.player.x, state.player.y);
      const g = ctx.createRadialGradient(-6,-6,4, 0,0,state.player.r);
      g.addColorStop(0, '#fff'); g.addColorStop(1, '#9bdcff');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(0,0,state.player.r,0,Math.PI*2); ctx.fill();
      ctx.restore();

      // Hazards
      ctx.strokeStyle='#ffec99'; ctx.lineWidth=2;
      for(const hz of state.hazards){
        ctx.save(); ctx.translate(hz.x, hz.y); ctx.rotate(hz.rot);
        ctx.beginPath(); ctx.moveTo(-hz.r,0); ctx.lineTo(0,-hz.r); ctx.lineTo(hz.r,0); ctx.lineTo(0,hz.r); ctx.closePath(); ctx.stroke();
        ctx.restore();
      }
    }

    // Init
    resize();
    state.player.x = canvas.clientWidth/2;
    state.player.y = canvas.clientHeight/2;
  </script>
</body>
</html>
"""
with open('/mnt/data/index_mobile.html','w', encoding='utf-8') as f:
    f.write(html)

'/mnt/data/index_mobile.html'
